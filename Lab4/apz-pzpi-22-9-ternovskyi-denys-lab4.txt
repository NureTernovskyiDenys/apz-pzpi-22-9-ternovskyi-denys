Міністерство освіти і науки України Харківський національний університет радіоелектроніки

Кафедра програмної інженерії


Звіт
з лабораторної роботи №4
з дисципліни "Архітектура програмного забезпечення" з теми: "Масштабування бекенда"







Виконав	Перевірив
ст. гр. ПЗПІ-22-9	Дашенков Д. С.
Терновський Денис








2025
 
1	ІСТОРІЯ ЗМІН

Таблиця 1 – Історія змін

№	Дата	Версія звіту	Опис змін та виправлень
1	22.05.2025	0.1	Створено звіт

2	ЗАВДАННЯ

Тема: Масштабування бекенду.
В цій лабораторній роботі необхідно показати як можна масштабувати бекенд системи для роботи із великим навантаженням. Для цього, можна на вибір: масштабувати сервер горизонтально – багато копій сервера виконують однакові функції для різних користувачів; масштабувати сервер вертикально – різні мікросервіси виконують різні функції і масштабуються окремо одне від одного. На найвищий бал на цю роботу необхідно провести навантажувальне тестування за допомогою Gatling, JMeter, Locust чи іншого подібного інструмента і показати як зі збільшенням кількості серверів зростає кількість запитів на секунду яку витримує система.

3	ОПИС ВИКОНАНОЇ РОБОТИ

3.1	Налаштування тестового середовища
Використані інструменти та методи:
	Власний Node.js скрипт stress-test.js з HTTP-клієнтом
	Цільовий сервер: http://localhost:8080
	Операційна система: Windows (PowerShell)
	Node.js версія: 16+
Конфігурація rate limiting (змінена для тестування):
	Загальний лімітер сервера: збільшено з 100 до 10,000 запитів на 15 хвилин
	Лімітер аутентифікації: збільшено з 10 до 1,000 запитів на 15 хвилин
	Лімітер логіну: збільшено з 5 до 500 запитів на 15 хвилин
	Лімітер AI: збільшено з 20 до 2,000 запитів на 15 хвилин
Архітектура тестування:
1.	Змішані сценарії навантаження з розподілом: 
a.	Health Check (40% запитів)
b.	User Registration (20% запитів)
c.	User Login (30% запитів)
d.	Get Profile (20% запитів)
2.	Генерація унікальних тестових користувачів для кожного запиту
3.	Випадкова затримка між запитами (1-3 секунди)
4.	Таймаут запитів: 10 секунд

3.2	Результати тестування
Тест 1: Базове навантаження
Команда: node stress-test.js
Конфігурація за замовчуванням: 10 одночасних користувачів, 70 секунд

Результати:
	Успішність: 100% (227/227 запитів)
	Пропускна здатність: 3.24 запитів/сек
	Середній час відповіді: 1,150 мс
	Мінімальний час: 2.65 мс
	Максимальний час: 4,074 мс
	P50: 938 мс
	P95: 2,805 мс
	P99: 3,633 мс
	Розподіл HTTP кодів: 200 (166), 201 (61)
	Помилки: 0

Тест 2: Високе навантаження
Команда: node stress-test.js --concurrency 50 --duration 300000
Конфігурація: 50 одночасних користувачів, 300 секунд (5 хвилин)

Результати:
	Успішність: 40.28% (841/2088 запитів)
	Пропускна здатність: 6.74 запитів/сек
	Середній час відповіді: 7,073 мс
	Мінімальний час: 14.75 мс
	Максимальний час: 10,242 мс
	P50: 10,002 мс
	P95: 10,015 мс
	P99: 10,041 мс
Розподіл HTTP кодів: 200 (837), 201 (4)
Помилки: 1,247 timeouts (59.72%)

3.3	Технічний аналіз результатів
Порівняльна таблиця метрик:
Параметр	Тест 1 (10 користувачів)	Тест 2 (50 користувачів)	Зміна
Успішність	100%	40.28%	-59.72%
Середній час відповіді	1,150 мс	7,073 мс	+515%
RPS	3.24	6.74	+108%
P95	2,805 мс	10,015 мс	+257%
P99	3,633 мс	10,041 мс	+176%
Максимальний час	4,074 мс	10,242 мс	+151%
Виявлені проблеми:
	Критична точка відмови: Сервер не витримує навантаження понад 10-20 одночасних користувачів
	Таймаути запитів: При навантаженні 50 користувачів 59.72% запитів перевищують 10-секундний таймаут
	Деградація продуктивності: Нелінійне зростання часу відповіді при збільшенні навантаження
	Вузькі місця: P95 та P99 метрики показують, що сервер досягає максимального таймауту
Аналіз причин проблем:
	Обмеження ресурсів: Сервер може бути обмежений CPU або пам'яттю
	База даних: MongoDB може не витримувати велику кількість одночасних підключень
	Event Loop блокування: Node.js може блокуватися на довготривалих операціях
	Мережеві обмеження: Локальне тестування може мати обмеження TCP-підключень
Рекомендації для оптимізації:
Інфраструктурні зміни:
	Збільшити connection pool для MongoDB
	Налаштувати індекси в базі даних для оптимізації запитів
	Збільшити heap size для Node.js процесу
	Розглянути використання кластеризації Node.js
Код-рівневі оптимізації:
	Реалізувати кешування для частих запитів (Redis)
	Оптимізувати middleware ланцюжки
	Використовувати async/await правильно для уникнення блокування
	Додати graceful degradation для високого навантаження
Моніторинг та метрики:
	Додати APM моніторинг (наприклад, New Relic)
	Реалізувати health checks з метриками
	Налаштувати логування продуктивності

Висновок:
Тестування показало, що сервер стабільно працює при навантаженні до 10 одночасних користувачів з відмінними показниками продуктивності (100% успішність, 1.15 сек середній час відповіді). Однак при збільшенні навантаження до 50 користувачів система демонструє критичну деградацію з успішністю лише 40.28% та семикратним зростанням часу відповіді. Це вказує на необхідність масштабування та оптимізації перед розгортанням у продуктивному середовищі

Посилання на GitHub: 
Посилання на YouTube:  
 
ДОДАТОК А
Генерацiя звiтностi
node stress-test.js
 

 
node stress-test.js --concurrency 50 --duration 300000
 
